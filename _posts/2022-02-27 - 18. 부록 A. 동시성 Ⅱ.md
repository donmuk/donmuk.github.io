# 동시성 Ⅱ
* 클라이언트/서버
  * 애플리케이션이 어디서 시간을 보내는지
    * I/O - 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간을 보낸다.
    * 프로세서 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등에 시간을 보낸다.
    * 프로그램이 주로 프로세서 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높인다.
    * 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여주기도 한다. 
  * 다중 스레드 프로그램을 깨끗하게 유지하려면 잘 통제된 몇 곳으로 스레드 관리를 모아야 한다. 스레드를 관리하는 코드는 스레드만 관리해야 한다.(단일 책임 원칙)
  * 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다.
* 가능한 실행 경로
  * 중단이 불가능한 연산을 원자적 연산이라고 한다.
  * 프레임: frame - 모든 메서드 호출에는 프레임이 필요하다. 프레임은 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역 변수를 포함한다. 프레임은 호출 스택을 정의할 때 사용하는 표준 기법이다. 현대 언어는 호출 스택으로 기본 함수/메서드 호출과 재귀적 호출을 지원한다.
  * 지역 변수 - 메서드 범위 내에 정의되는 모든 변수를 가리킨다. 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역 변수를 갖는다. this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 메서드를 호출한 객체를 가리킨다.
  * 피연산자 스택 - JVM이 지원하는 명령 대다수는 매개변수를 받는다. 피연산자 스택은 이런 매개변수를 저장하는 장소다. 피연산자 스택은 표준 LIFO(last in, first out) 자료 구조다.
  * 어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다. 전처리 연산과 후처리 연산 모두 (++) 원자적 연산이라 오해하는 사람이 많은데, ++ 연산은 분명히 원자적 연산이 아니다.
  * 공유 객체/값이 있는 곳, 동시 읽기/수정 문제를 일으킬 소지가 있는 코드, 동시성 문제를 방지하는 방법을 알고 있어야 한다.
* 라이브러리를 이해하라
  * Executor 프레임워크는 스레드 풀링으로 정교한 실행을 지원한다. Executor는 java.util.concurrent 패키지에 속하는 클래스다.
  * 애플리케이션에서 스레드는 생성하나 스레드 풀을 사용하지 않는다면 혹은 직접 생성한 스레드 풀을 사용한다면 Executor 클래스를 고려한다. 코드가 깔끔해지고, 이해하기 쉬워지고, 크기가 작아진다.
  * Executor 프레임워크는 스레드 풀을 관리하고, 풀 크기를 자동으로 조정하며, 필요하다면 스레드를 재사용한다. 게다가 다중 스레드 프로그래밍에서 많이 사용하는 Future도 지원한다. 또한 Runnable 인터페이스를 구현한 클래스는 물론 Callable 인터페이스를 구현한 클래스도 지원한다. Callable 인터페이스는 Runnable 인터페이스와 유사하지만 결과 값을 반환한다. 결과 값은 다중 스레드 환경에서 흔히 요구되는 사항이다.
  * 최신 프로세서는 스레드를 차단하지 않고도(non blocking) 안정적으로 값을 갱신한다. 자바 5 VM은 이를 이용한다.
  * 다중 스레드 환경에서 안전하지 않은 클래스
    * SimpleDateFormat
    * 데이터베이스 연결
    * java.util 컨테이너 클래스
    * 서블릿
  * java.util.concurrent 패키지가 제공하는 집합 클래스는 스레드에 안전한 메서드를 제공한다.
* 메서드 사이에 존재하는 의존성을 조심하라
  * 메서드 사이에 존재하는 의존성 때문에 나타나는 버그는 시스템을 출시하고도 오랜 시간이 지나서야 발생하고, 추적하기도 어렵다. 해결 방안은 세 가지다.
    * 실패를 용인한다.
    * 클라이언트를 바꿔 문제를 해결한다. 클라이언트-기반 잠금 메커니즘을 구현한다.
    * 서버를 바꿔 문제를 해결한다. 서버에 맞춰 클라이 언트도 바꾼다. 즉, 서버-기반 잠금 메커니즘을 구현한다.
    * 일반적으로 서버-기반 잠금이 더 바람직하다. 이유는 다음과 같다.
      1. 코드 중복이 줄어든다. 클라이언트-기반 잠금 메커니즘은 각 클라이언트가 알아서 서버를 잠궈야 한다. 잠금 메커니즘을 서버에 구현하면 클라이언트는 자유롭게 객체를 사용할뿐더러 클라이언트에 잠금 코드를 추가할 필요도 없어진다.
      2. 성능이 좋아진다. 단일스레드 환경으로 시스템을 배치할 경우 (다중 스레드 서버를 단일 스레드 서버로) 서버만 교체하면 오버헤드가 줄어든다.
      3. 오류가 발생할 가능성이 줄어든다. 잠금을 잊어버리는 바람에 오류가 발생할 위험은 프로그래머 한 명으로 제한된다.
      4. 스레드 정책이 하나다. 클라이언트-기반 잠금은 각 클라이언트가 정책을 구현하는 반면, 서버-기반 잠금은 서버 한곳에서 정책을 구현한다.
      5. 공유 변수 범위가 줄어든다. 클라이언트가 공유 변수 자체를 모르거나 공유 변수가 잠긴 방식을 모른다. 모두가 서버에 숨겨진다. 문제가 생기면 살펴볼 곳이 적다.
      > 서버 코드에 손대지 못한다면 ADAPTER 패턴을 사용해 API를 변경한 후 잠금을 추가한다. 아니면, 더 좋은 방법으로, 스레드에 안전하며 인터페이스가 확장된 집합 클래스를 사용한다.
* 작업 처리량 높이기
  * 코드에서 synchronized 블록등 동기화 영역은 언제나 작을수록 좋다.
  * 순서에 무관한 프로그램이라면 다중 스레드가 단일 스레드에 비해 처리율이 훨씬 높다.
* 데드락
  * 다음 네 가지 조건을 모두 만족하면 데드락이 발생한다.
    1. 상호배제
      * 여러 스레드가 한 자원을 공유하나 그 자원은 여러 스레드가 동시에 사용하지 못하며 개수가 제한적이라면 상호 배제 조건을 만족한다. 데이터베이스 연결, 쓰기용 파일 열기, 레코드 락, 세마포어 등과 같은 자원이다.
    2. 잠금 & 대기
      * 일단 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.
    3. 선점 불가
      * 한 스레드가 다른 스레드로부터 자원을 빼앗지 못한다. 자원을 점유한 스레드가 스스로 내놓지 않는 이상 다른 스레드는 그 자원을 점유하지 못한다.
    4. 순환 대기
      * 죽음의 포옹이라고도 한다. T1, T2라는 스레드 두 개가 있으며 R1, R2라는 자원 두 개가 있다고 가정하자. T1이 R1을 점유하고 T2가 R2를 점유한다. 또한 T1은 R2가 필요하고 T2도 R2가 필요하다.
  * 상호 배제 조건 깨기
    * 동시에 사용해도 괜찮은 자원을 사용한다. 
    * 스레드 수 이상으로 자원 수를 늘인다.
    * 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다.
    * 불행하게도 대다수 자원은 그 수가 제한적인 데다 동시에 사용하기도 어렵다. 게다가 첫 번째 자원을 사용하고 나서야 두 번째로 필요한 자원이 밝혀지는 경우도 없지 않다.
  * 잠금 & 대기 조건 깨기
    * 대기하지 않으면 데드락이 발생하지 않는다. 각 자원을 점유하기 전에 확인한다. 만약 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원을 몽땅 내놓고 처음부터 다시 시작한다. 이 방법은 잠재적인 문제가 몇 가지 있다.
      * 기아 - 한 스레드가 계속해서 필요한 자원을 점유하지 못한다. 
      * 라이브락 - 여러 스레드가 한꺼번에 잠금 단계로 진입하는 바람에 계속해서 자원을 점유했다 내놨다를 반복한다. 단순한 CPU 스케줄링 알고리즘에서 특히 쉽게 발생한다.
    * 두 경우 모두가 자칫하면 작업 처리량을 크게 떨어뜨린다. 기아는 CPU 효율을 저하시키는 반면 라이브락은 쓸데 없이 CPU만 많이 사용한다.
    * 이런 전략이 비효율적으로 보일지도 모르지만 아무 대책이 없는 경우보다는 좋다. 모든 전략이 실패할 때 언제든 꺼내 들 카드라는 장점이 있다.
  * 선점 불가 조건 깨기
    * 데드락을 피하는 또 다른 전략은 다른 스레드로부터 자원을 뺏어오는 방법이다. 일반적으로 간단한 요청 메커니즘으로 처리한다. 필요한 자원이 잠겼다면 자원을 소유한 스레드에게 풀어달라 요청한다. 소유 스레드가 다른 자원을 기다리던 중이었다면 자신이 소유한 자원을 모두 풀어주고 처음부터 다시 시작한다.
    * 앞 전략과 비슷하지만 스레드가 자원을 기다려도 괜찮다는 이점이 있다. 그러면 처음부터 다시 시작하는 횟수가 줄어든다. 하지만 이 모든 요청을 관리하기가 간단하지 않다.
  * 순환 대기 조건 깨기
    * 데드락을 방지하는 가장 흔한 전략이다. 대다수 시스템에서는 모든 스레드가 동의하는 간단한 규약이면 충분하다.
    * R1을 점유한 T1이 R2를 기다리고 R2를 점유한 T2가 R1을 기다리는 앞서 예제에서 T1과 T2가 자원을 똑같은 순서로 할당하게 만들면 순환 대기는 불가능해진다. 
    * 좀 더 일반적으로, 모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당한다면 데드락은 불가능하다. 그러나 이 전략 역시 문제를 일으킬 소지가 있다.
      * 자원을 할당하는 순서와 자원을 사용하는 순서가 다를지도 모른다. 그래서 맨 처음 할당한 자원을 아주 나중에야 쓸지도 모른다. 즉, 자원을 꼭 필요한 이상으로 오랫동안 점유한다.
      * 때로는 순서에 따라 자원을 할당하기 어렵다. 첫 자원을 사용한 후에야 둘째 자원 ID를 얻는다면 순서대로 할당하기란 불가능하다.
> 데드락을 피하는 전략은 많다. 프로그램에서 스레드 관련 코드를 분리하면 조율과 실험이 가능하므로 통찰력이 높아져 최적의 전략을 찾기 쉬워진다.
* 실패를 증멸할 테스트 코드 작성
  * 몬테 카를로 테스트. 조율이 가능하게 유연한 테스트를 만든다. 그런 다음, 임의로 값을 조율하면서 반복해 돌린다. 테스트가 실패하면 버그가 있다는 증거다. 테스트는 일찌감치 작성하기 시작해 통합 서버에서 계속 돌린다. 참고로, 테스트가 실패한 조건은 신중하게 기록한다.
  * 시스템을 배치할 플랫폼 전부에서 테스트를 돌린다. 반복해서 돌린다. 테스트가 실패 없이 오래 돌아갈수록 두 가지 중 하나일 확률이 높아진다.
    1. 실제 코드가 올바르다.
    2. 테스트가 부족해 문제를 드러내지 못한다. 
  * 부하가 변하는 장비에서 테스트를 돌린다. 실제 환경과 비슷하게 부하를 걸어줄 수 있다면 그렇게 한다.
* 스레드 코드 테스트를 도와주는 도구
  * IBM은 ConTest라는 도구를 내놓았다. 스레드에 안전하지 않는 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구다. 다음은 ConTest를 사용하는 방법이다.
    * 실제 코드와 테스트 코드를 작성한다. 다양한 부하 상황에서 여러 사용자를 시뮬레이션하는 테스트도 빼놓지 않는다.
    * ConTest로 실제 코드와 테스트 코드에 보조 코드를 추가한다.
    * 테스트를 실행한다.
    > 보조 코드를 추가한 클래스는 훨씬 더 빠르고 확실히 실패한다.
<hr/>

### 결론
> 다중 스레드 시스템을 구현하려면 알아야 할 내용이 아주 많다. 
  
